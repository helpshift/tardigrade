(ns tardigrade.circuit-breaker.counter
  (:require [clj-time.core :as time]
            [tardigrade.circuit-breaker.protocols :as tcp]))


(defn trip-counter-failure-hit
  [state threshold]
  (swap! state
         (fn [v]
           (if (>= (get v :failure-counter 0)
                   threshold)
             (-> v
                 (assoc-in [:last-failed-time]
                           (time/now))
                 ;; Reset failure counter to 1. This is for following case.
                 ;; If there is a timeout of 20 seconds and threshold for errors is 5.
                 ;; - We see 5 continuous errors
                 ;; - Circuit is tripped for next 20 seconds
                 ;; - After 20 seconds. We see more errors.
                 ;; If we don't reset the failure counter. The circuit
                 ;; will trip on the first failure.
                 (assoc-in [:failure-counter]
                           1))
             (update-in v
                        [:failure-counter]
                        (fnil inc 1))))))


(defn trip-counter-failure-reset
  [state]
  (swap! state
         (fn [v]
           (-> v
               (assoc-in [:failure-counter]
                         1)
               (assoc-in [:last-failed-time]
                         nil)))))


(defn circuit-tripped?
  "ctx - Circuit breaker context generated by init-circuit-breaker
   circuit-breaker-name - Name of external dependency. Only keywords allowed.
                          Ex. :redis, :postgres"
  [state timeout]
  (when-let [last-time-failed (:last-failed-time state)]
    (let [millis (time/in-seconds (time/interval last-time-failed
                                                 (time/now)))]
      (< millis
         timeout))))


(defrecord CounterCB
    [circuit-breaker-name state failure-pred threshold timeout]
  tcp/Trippable
  (tripped? [this]
    (circuit-tripped? @state timeout))
  (run-body [this body-fn]
    (try
      (let [res (body-fn)]
        (trip-counter-failure-reset state)
        [::tcp/success res])
      (catch Throwable e
        (if (failure-pred e)
          (do ;; (log :error
              ;;      "Exception supressed by circuit breaker"
              ;;      e
              ;;     {:circuit-breaker-name circuit-breaker-name})
              (trip-counter-failure-hit state
                                        threshold)
              [::tcp/failure e])
          (throw e))
        [::tcp/failure e])))
  (reset-trip [this]
    (trip-counter-failure-reset state)))


(defn create-counter-trippable
  [circuit-breaker-name
   {:keys [timeout threshold failure-pred]
    :or {timeout 60
         failure-pred (constantly true)
         threshold 5}}]
  (let [a (atom {})]
    (map->CounterCB {:circuit-breaker-name circuit-breaker-name
                     :state a
                     :failure-pred failure-pred
                     :threshold threshold
                     :timeout timeout})))
